<!doctype html>

<head>
    <meta charset="utf-8">
    <title>Kindle Scribe TXT Cleaner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A browser tool for cleaning Kindle Scribe Chinese handwriting exports.">
    <meta name="robots" content="index,follow">
    <meta name="author" content="Generated by ChatGPT-5.1">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta name="theme-color" content="#f5f5f7">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            margin: 20px;
            background-color: #f5f5f7;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 12px;
            padding: 20px 24px 24px 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        h1 {
            font-size: 20px;
            margin-top: 0;
            margin-bottom: 12px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }

        .controls label {
            font-size: 14px;
        }

        input[type="file"] {
            font-size: 13px;
        }

        button {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 1px solid #d0d0d0;
            background-color: #f0f0f0;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        button.primary {
            background-color: #007aff;
            border-color: #007aff;
            color: #ffffff;
        }

        .btn-icon {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 1.6;
            stroke-linecap: round;
            stroke-linejoin: round;
            flex-shrink: 0;
        }

        .file-info {
            font-size: 12px;
            color: #666666;
            margin-bottom: 8px;
        }

        textarea {
            width: 100%;
            min-height: 420px;
            box-sizing: border-box;
            padding: 8px;
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 13px;
            border-radius: 8px;
            border: 1px solid #d0d0d0;
            resize: vertical;
            white-space: pre-wrap;
        }

        textarea.drag-over {
            border-color: #007aff;
            background-color: #f0f6ff;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
        }

        .hint {
            font-size: 12px;
            color: #777777;
            margin-top: 6px;
        }
    </style>
</head>

<body>
    <a href="https://github.com/Reedo0910/kindle-scribe-txt-cleaner" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80"
            viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
            aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z" />
            <path
                d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm" />
            <path
                d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                fill="currentColor" class="octo-body" />
        </svg></a>
    <style>
        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out
        }

        @keyframes octocat-wave {

            0%,
            100% {
                transform: rotate(0)
            }

            20%,
            60% {
                transform: rotate(-25deg)
            }

            40%,
            80% {
                transform: rotate(10deg)
            }
        }

        @media (max-width:500px) {
            .github-corner:hover .octo-arm {
                animation: none
            }

            .github-corner .octo-arm {
                animation: octocat-wave 560ms ease-in-out
            }
        }
    </style>
    <div class="container">
        <h1>Kindle Scribe TXT Cleaner</h1>

        <div class="controls">
            <label for="fileInput">选择 TXT 文件：</label>
            <input type="file" id="fileInput" accept=".txt">
        </div>

        <div id="fileInfo" class="file-info">尚未载入文件。</div>

        <textarea id="output" placeholder="清理后的文本会显示在这里。你也可以将 Kindle 导出的 TXT 文件拖拽到此处，或者粘贴原始文本，然后点击下方的「清理」。"></textarea>

        <div class="actions">
            <button id="cleanButton" class="primary" disabled>
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <circle cx="12" cy="12" r="9"></circle>
                    <path d="M8 12l3 3 5-5"></path>
                </svg>
                <span>清理</span>
            </button>

            <button id="downloadButton" disabled>
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 4v10"></path>
                    <path d="M8 10l4 4 4-4"></path>
                    <path d="M6 18h12"></path>
                </svg>
                <span>导出 TXT</span>
            </button>

            <button id="downloadMdButton" disabled>
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="4" y="4" width="16" height="16" rx="2"></rect>
                    <path d="M7 15v-6l2.5 3 2.5-3v6"></path>
                    <path d="M15 15v-6h2"></path>
                </svg>
                <span>导出 MD</span>
            </button>

            <button id="copyButton" disabled>
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="9" y="9" width="10" height="10" rx="2"></rect>
                    <rect x="5" y="5" width="10" height="10" rx="2"></rect>
                </svg>
                <span>复制</span>
            </button>
        </div>

        <!-- <div class="hint">
            小提示：你可以直接把 Kindle 导出的 TXT 文件拖拽到上面的文本框，或者粘贴原始文本，然后点击下面的「清理」。
        </div> -->
    </div>

    <script>
        // Core cleaning logic
        function cleanKindleText(raw) {
            if (!raw) {
                return "";
            }

            // 1) Normalize line endings
            let text = raw.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

            // 2) Remove zero-width characters and ˊ (U+02CA)
            text = text.replace(/[\u00AD\u200B\u200C\u200D\uFEFF\u2060\u02CA]/g, "");

            // 3) Remove full-line "第 x 页"
            text = text.replace(/^第\s*\d+\s*页\s*$/gm, "");

            // Remove leading blank lines
            text = text.replace(/^\n+/, "");

            // 4) Merge sentence splits caused by page breaks
            const punct = "。！？；：，,、.…\"”’')】》";
            const pattern = /([^\n])(\n{2,})([^\n])/g;

            let changed = true;
            while (changed) {
                changed = false;
                text = text.replace(pattern, function (match, prev, breaks, next) {
                    if (punct.indexOf(prev) === -1) {
                        changed = true;
                        return prev + next;
                    } else {
                        const replacement = prev + "\n\n" + next;
                        if (replacement !== match) {
                            changed = true;
                        }
                        return replacement;
                    }
                });
            }

            // 5) Protect ASCII dashes and long dashes of length >= 3
            const asciiDashSequences = [];
            text = text.replace(/-{3,}/g, function (match) {
                const token = "<<<TRIPLE_ASCII_DASH_" + asciiDashSequences.length + ">>>";
                asciiDashSequences.push(match);
                return token;
            });

            const cnDashSequences = [];
            const cnDashRegex = /[\u2014]{3,}/g;
            text = text.replace(cnDashRegex, function (match) {
                const token = "<<<TRIPLE_CN_DASH_" + cnDashSequences.length + ">>>";
                cnDashSequences.push(match);
                return token;
            });

            // 6) Remove stray dots that are not between Latin letters or digits
            text = text.replace(/(^|[^0-9A-Za-z])\./g, function (match, p1) {
                return p1;
            });

            // 7) Normalize half-width commas to full-width and trim spaces around them
            text = text.replace(/\s*,\s*/g, "，");

            // 8) Collapse repeated Chinese commas and periods
            text = text.replace(/，{2,}/g, "，");
            text = text.replace(/。{2,}/g, "。");

            // 9) Convert normal hyphen "-" to Chinese dash (two U+2014)
            text = text.replace(/-/g, "\u2014\u2014");

            // 10) Convert English colon to Chinese colon
            text = text.replace(/:/g, "：");

            // 11) Remove spaces before common Chinese punctuation
            text = text.replace(/\s+([。！？；：、，])/g, "$1");

            // 12) Remove underscores
            text = text.replace(/_/g, "");

            // 13) Trim trailing spaces and tabs at line end
            text = text.replace(/[ \t]+$/gm, "");

            // 14) Convert ASCII double quotes to Chinese quotes (alternating open/close)
            let isOpenQuote = true;
            text = text.replace(/"/g, function () {
                const ch = isOpenQuote ? "“" : "”";
                isOpenQuote = !isOpenQuote;
                return ch;
            });

            // 15) Insert an extra blank line after sentence-ending punctuation
            //     including closing double quote, when followed by a non-empty next line
            text = text.replace(/([。！？…”])\n([^\n])/g, "$1\n\n$2");

            // 16) Collapse 3 or more consecutive newlines into 2
            text = text.replace(/\n{3,}/g, "\n\n");

            // 17) Strip extra blank lines at file edges
            text = text.replace(/^\n+|\n+$/g, "");

            // 18) Restore protected dash sequences
            text = text.replace(/<<<TRIPLE_ASCII_DASH_(\d+)>>>/g, function (match, index) {
                const i = parseInt(index, 10);
                return asciiDashSequences[i] !== undefined ? asciiDashSequences[i] : "";
            });

            text = text.replace(/<<<TRIPLE_CN_DASH_(\d+)>>>/g, function (match, index) {
                const i = parseInt(index, 10);
                return cnDashSequences[i] !== undefined ? cnDashSequences[i] : "";
            });

            return text;
        }

        // DOM elements
        const fileInput = document.getElementById("fileInput");
        const cleanButton = document.getElementById("cleanButton");
        const downloadButton = document.getElementById("downloadButton");
        const downloadMdButton = document.getElementById("downloadMdButton");
        const copyButton = document.getElementById("copyButton");
        const output = document.getElementById("output");
        const fileInfo = document.getElementById("fileInfo");

        let currentRawText = "";
        let currentCleanedText = "";
        let currentFileName = "";

        // Helper to load a text file (used by both input and drag-and-drop)
        function loadTextFile(file) {
            if (!file) {
                fileInfo.textContent = "尚未载入文件。";
                cleanButton.disabled = false;
                return;
            }

            // Only allow plain text or .txt files
            if (file.type && file.type !== "text/plain" && !/\.txt$/i.test(file.name)) {
                fileInfo.textContent = "仅支持 TXT 文本文件。";
                return;
            }

            const reader = new FileReader();
            reader.onload = function (event) {
                currentRawText = event.target.result;
                currentFileName = file.name;
                fileInfo.textContent = "已载入文件：" + file.name + "（" + file.size + " 字节）";

                output.value = currentRawText;
                cleanButton.disabled = false;
            };
            reader.onerror = function () {
                fileInfo.textContent = "读取文件失败。";
                cleanButton.disabled = true;
            };

            reader.readAsText(file, "utf-8");
        }

        // Handle file selection
        fileInput.addEventListener("change", function () {
            const file = fileInput.files && fileInput.files[0];
            loadTextFile(file);
        });

        // Handle drag and drop on textarea
        ["dragenter", "dragover"].forEach(function (eventName) {
            output.addEventListener(eventName, function (e) {
                e.preventDefault();
                e.stopPropagation();
                output.classList.add("drag-over");
            });
        });

        ["dragleave", "drop"].forEach(function (eventName) {
            output.addEventListener(eventName, function (e) {
                e.preventDefault();
                e.stopPropagation();
                output.classList.remove("drag-over");
            });
        });

        output.addEventListener("drop", function (e) {
            e.preventDefault();
            e.stopPropagation();
            output.classList.remove("drag-over");

            const dt = e.dataTransfer;
            if (!dt || !dt.files || !dt.files.length) {
                return;
            }
            const file = dt.files[0];
            loadTextFile(file);
        });

        // Handle "Clean" button click
        cleanButton.addEventListener("click", function () {
            let sourceText = currentRawText;
            if (!sourceText) {
                sourceText = output.value || "";
            }

            const cleaned = cleanKindleText(sourceText);
            currentCleanedText = cleaned;
            output.value = cleaned;

            const lengthInfo = cleaned.length
                ? "文本长度：" + cleaned.length + " 个字符。"
                : "没有可清理的文本。";
            fileInfo.textContent = lengthInfo + (currentFileName ? " 来源文件：" + currentFileName : "");

            const hasText = cleaned.length > 0;
            downloadButton.disabled = !hasText;
            downloadMdButton.disabled = !hasText;
            copyButton.disabled = !hasText;
        });

        // Download TXT
        downloadButton.addEventListener("click", function () {
            if (!currentCleanedText) {
                return;
            }

            let downloadName = "kindle.txt";
            if (currentFileName) {
                downloadName = currentFileName.replace(/\.txt$/i, "") + ".txt";
            }

            const blob = new Blob([currentCleanedText], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = downloadName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        });

        // Download MD
        downloadMdButton.addEventListener("click", function () {
            if (!currentCleanedText) {
                return;
            }

            let downloadName = "kindle.md";
            if (currentFileName) {
                downloadName = currentFileName.replace(/\.txt$/i, "") + ".md";
            }

            const blob = new Blob([currentCleanedText], { type: "text/markdown;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = downloadName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        });

        // Copy to clipboard
        copyButton.addEventListener("click", function () {
            if (!currentCleanedText) {
                return;
            }

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(currentCleanedText).then(function () {
                    fileInfo.textContent = "文本已复制到剪贴板。";
                }).catch(function () {
                    fileInfo.textContent = "复制到剪贴板失败。";
                });
            } else {
                output.focus();
                output.select();
                fileInfo.textContent = "请手动全选后复制。";
            }
        });

        // Allow cleaning pasted text without a file
        cleanButton.disabled = false;
    </script>
</body>

</html>